#include "can.h"
#include "main.h"

// Экземпляры и внешние переменные
extern CAN_HandleTypeDef hcan1;
extern UART_HandleTypeDef huart2;

// Функция инициализации CAN с настройкой фильтра для ID 0x65D и 0x651
void CAN1_Init_Custom(void) {
    CAN_FilterTypeDef canFilter;
    canFilter.FilterActivation = ENABLE;
    canFilter.FilterBank = 0;
    canFilter.FilterFIFOAssignment = CAN_RX_FIFO0;
    canFilter.FilterIdHigh = 0x65D << 5;  // Устанавливаем ID 0x65D (основной ID)
    canFilter.FilterIdLow = 0x0000;
    canFilter.FilterMaskIdHigh = 0xFFE0;  // Маска для точного совпадения с ID
    canFilter.FilterMaskIdLow = 0x0000;
    canFilter.FilterMode = CAN_FILTERMODE_IDMASK;
    canFilter.FilterScale = CAN_FILTERSCALE_32BIT;

    if (HAL_CAN_ConfigFilter(&hcan1, &canFilter) != HAL_OK) {
        HAL_UART_Transmit(&huart2, (uint8_t *)"CAN Filter Config Failed!\r\n", 27, HAL_MAX_DELAY);
        Error_handler();
    }

    // Включение уведомлений для приема сообщений
    if (HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK) {
        HAL_UART_Transmit(&huart2, (uint8_t *)"CAN Notification Activation Failed!\r\n", 38, HAL_MAX_DELAY);
        Error_handler();
    }

    // Запуск CAN
    if (HAL_CAN_Start(&hcan1) != HAL_OK) {
        HAL_UART_Transmit(&huart2, (uint8_t *)"CAN Start Failed!\r\n", 19, HAL_MAX_DELAY);
        Error_handler();
    }
}

// Обработчик прерываний для приема сообщений по CAN (FIFO0)
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
    CAN_RxHeaderTypeDef RxHeader;
    uint8_t rcvd_msg[8];
    char msg[50];

    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, rcvd_msg) != HAL_OK) {
        Error_handler();
    }

    if (RxHeader.StdId == 0x65D && RxHeader.RTR == 0) {
        // Это кадр данных с ID 0x65D
        LED_Manage_Output(rcvd_msg[0]);
        sprintf(msg, "Message Received: #%x\r\n", rcvd_msg[0]);
    }
    else if (RxHeader.StdId == 0x651 && RxHeader.RTR == 1) {
        // Это удаленный кадр (Remote frame) с ID 0x651
        Send_response(RxHeader.StdId);
        return;
    }
    else if (RxHeader.StdId == 0x651 && RxHeader.RTR == 0) {
        // Это ответный кадр (reply) от ID 0x651
        sprintf(msg, "Reply Received: %#X\r\n", rcvd_msg[0] << 8 | rcvd_msg[1]);
    }

    HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
}

// Функция управления светодиодом
void LED_Manage_Output(uint8_t led_no) {
    // Здесь можно добавить логику управления светодиодом в зависимости от `led_no`
}

// Функция для отправки ответа на запрос
void Send_response(uint32_t StdId) {
    CAN_TxHeaderTypeDef TxHeader;
    uint32_t TxMailbox;
    uint8_t response[2] = {0xAB, 0xCD};  // Пример ответа

    TxHeader.DLC = 2;
    TxHeader.StdId = StdId;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.RTR = CAN_RTR_DATA;

    if (HAL_CAN_AddTxMessage(&hcan1, &TxHeader, response, &TxMailbox) != HAL_OK) {
        Error_handler();
    }
}

// Функция обработки ошибок
void Error_handler(void) {
    HAL_UART_Transmit(&huart2, (uint8_t *)"Entering Error Handler\r\n", 24, HAL_MAX_DELAY);
    __disable_irq();  // Отключаем прерывания
    while (1) {
        // Здесь можно добавить индикацию ошибки с помощью светодиода
    }
}
