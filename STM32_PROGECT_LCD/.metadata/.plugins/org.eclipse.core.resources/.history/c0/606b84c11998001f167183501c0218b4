#include "SM1810C.h"
#include "stm32f4xx_hal_uart.h"
#include <stdio.h>
#include <string.h>

extern CAN_HandleTypeDef hcan1;
extern UART_HandleTypeDef huart2;

static CAN_TxHeaderTypeDef TxHeader;
static CAN_RxHeaderTypeDef RxHeader;
static uint8_t TxData[8];
static uint8_t RxData[8];
static uint32_t TxMailbox;

void SM1810C_Init(void) {
    // Настройка заголовка CAN для запроса к датчику
    TxHeader.StdId = 0x01;       // ID устройства SM1810C
    TxHeader.RTR = CAN_RTR_DATA; // Data frame
    TxHeader.IDE = CAN_ID_STD;   // Standard frame
    TxHeader.DLC = 6;            // Длина данных для запроса

    // Настройка фильтра для приёма сообщений с ID 0x01
    CAN_FilterTypeDef sFilterConfig;
    sFilterConfig.FilterBank = 0;
    sFilterConfig.FilterMode = CAN_FILTERMODE_IDLIST;
    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
    sFilterConfig.FilterIdHigh = 0x01 << 5;   // ID 0x01 в формате фильтра CAN
    sFilterConfig.FilterIdLow = 0x0000;
    sFilterConfig.FilterMaskIdHigh = 0xFFFF;  // Маска для точного совпадения
    sFilterConfig.FilterMaskIdLow = 0x0000;
    sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
    sFilterConfig.FilterActivation = ENABLE;

    if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK) {
        HAL_UART_Transmit(&huart2, (uint8_t*)"ERROR: CAN filter configuration failed\r\n", 40, HAL_MAX_DELAY);
    } else {
        HAL_UART_Transmit(&huart2, (uint8_t*)"CAN filter configured successfully\r\n", 36, HAL_MAX_DELAY);
    }

    // Запуск CAN
    if (HAL_CAN_Start(&hcan1) != HAL_OK) {
        HAL_UART_Transmit(&huart2, (uint8_t*)"ERROR: CAN start failed\r\n", 26, HAL_MAX_DELAY);
    } else {
        HAL_UART_Transmit(&huart2, (uint8_t*)"CAN started successfully\r\n", 27, HAL_MAX_DELAY);
    }

    // Включаем прерывание для приёма сообщений
    if (HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK) {
        HAL_UART_Transmit(&huart2, (uint8_t*)"ERROR: CAN notification activation failed\r\n", 44, HAL_MAX_DELAY);
    } else {
        HAL_UART_Transmit(&huart2, (uint8_t*)"CAN notifications activated\r\n", 30, HAL_MAX_DELAY);
    }
    HAL_UART_Transmit(&huart2, (uint8_t*)"SM1810C initialized and ready\r\n", 32, HAL_MAX_DELAY);
}

void SM1810C_RequestData(void) {
    // Команда для запроса данных температуры и влажности
    TxData[0] = 0x01; // Тип фрейма
    TxData[1] = 0x03; // Код функции для чтения данных
    TxData[2] = 0x00; // Старший байт начального адреса
    TxData[3] = 0x00; // Младший байт начального адреса
    TxData[4] = 0x00; // Старший байт длины данных
    TxData[5] = 0x02; // Младший байт длины данных

    // Отправка CAN сообщения
    if (HAL_CAN_AddTxMessage(&hcan1, &TxHeader, TxData, &TxMailbox) != HAL_OK) {
        HAL_UART_Transmit(&huart2, (uint8_t*)"ERROR: Failed to send CAN message\r\n", 35, HAL_MAX_DELAY);
    } else {
        HAL_UART_Transmit(&huart2, (uint8_t*)"Query sent successfully\r\n", 26, HAL_MAX_DELAY);
    }
}

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData) == HAL_OK) {
        // Проверяем, что ID и длина данных соответствуют
        if (RxHeader.StdId == 0x01 && RxHeader.DLC == 7) {
            // Раскодируем данные из ответа
            uint16_t temperature_raw = (RxData[3] << 8) | RxData[4];
            float temperature = temperature_raw / 100.0f;
            uint16_t humidity_raw = (RxData[5] << 8) | RxData[6];
            float humidity = humidity_raw / 100.0f;

            // Выводим результат через UART
            char buffer[64];
            snprintf(buffer, sizeof(buffer), "Temp: %.2f°C, Humidity: %.2f%%RH\r\n", temperature, humidity);
            HAL_UART_Transmit(&huart2, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
        } else {
            HAL_UART_Transmit(&huart2, (uint8_t*)"ERROR: Invalid CAN response ID or DLC\r\n", 39, HAL_MAX_DELAY);
        }
    } else {
        HAL_UART_Transmit(&huart2, (uint8_t*)"ERROR: No response in CAN FIFO0\r\n", 34, HAL_MAX_DELAY);
    }
}
